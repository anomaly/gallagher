{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gallagher Python Toolkit","text":"<p>Gallagher Security manufacture a variety of perimeter security products. At the hear of these is the Command Centre software. Command Centre is deployed locally (in simplistic terms, the complexity varies for every use case). Version <code>8.6</code> introduced a REST API which allows you to interact with the system via HTTP requests locally or via Gallagher's Cloud API Gateway which eliminates the need for maintaining proxies and VPNs.</p> <p>Our Python Toolkit focuses on enhancing the developer experience (DX) around the REST API. In principle we provide the following:</p> <ul> <li>Python SDK an idiomatic client (including <code>asyncio</code> support) to extend the CC functionality.</li> <li>Command Line Interface (CLI) to build powerful pipeline-based workflows.</li> <li>Terminal User Interface (TUI) for easy interactions with the Command Centre.</li> <li>SQL interface query the REST API as if it were a database or interact with via an ORM.</li> </ul> <p>Note</p> <p>Anomaly is part of Gallagher's Technical Partner Program, however this project is not officially affiliated with Gallagher and is solely maintained by Anomaly.</p>"},{"location":"#how-to-get-started","title":"How to get started?","text":"<p>The offerings of this project are aimed at two significant groups of users:</p> <ul> <li>Software engineers who are looking to integrate Gallagher's technology into their systems</li> <li>Advanced users who are looking to automate their workflows</li> </ul> <p>If you are a developer, the first things that might excite you are:</p> <ul> <li>Python idiomatic client that adheres to the standards outlined by Gallagher</li> <li>SQL interface to the REST API that allows you to interact with the API using SQL queries</li> </ul> <p>As an advanced user or integrator, we recommend at looking at:</p> <ul> <li>Command line interface that allows you to interact with the API from the terminal</li> <li>Terminal interface that provides a subset of the command centre functions in a different viewpoint</li> </ul> <p>All of our tools are written using the Python programming languages. We provide binaries for most popular operating systems. If you are a developer and would like to contribute to the project, a good place to start is our design document.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Gallagher publish their API reference which is built from an OpenAPI spec with Spectacle documentation generator flavours. The OpenAPI spec is maintained by hand and can be found on Github.</p> <p>Even with substantial documentation, it can be overwhelming to interact with the API directly due to concerns of security, understanding various Internet standards.</p> <p>Our Python Toolkit aims to encapsulate the design requirements of the API and provide a Python interface for you to build your integrations. Simply put:</p> <p>Tip</p> <p>\"You write Python, we speak REST to Gallagher's standards.\"</p> <p>As we provided the viability of our commercial projects around Gallagher's infrastructure our support load went through the roof, the CLI, TUI and SQL interfaces are a formal expression of scripts, REST payload snippets that we used in the early days to perform tasks like adding cards to cardholders or keeping track of visits.</p> <p>The API client draws inspiration from the works of Stripe or pyndatic who are known for providing a superb developer experience. Our aim is to provide a similar quality of developer experience for Gallagher projects.</p> <p>This project was started off in solving a problem for ourselves, but we hope that many of you out there enjoy the developer experience if brings.</p>"},{"location":"#background","title":"Background","text":"<p>Anomaly has a long history of working with APIs. In the early 2010s, during the early days of JSON APIs, we build a framework in Python called prestans, it was designed to encompass the best practices of RESTful API design by providing a programmatic interface in Python. It allowed us to build large scale applications without losing quality as the team scaled up.</p> <p>prestans has since been superseded by projects like pydantic and FastAPI, what we learnt from building it stayed with us. We've played on our strengths of deeply understanding the underlying protocol, design patterns and philosophy of the Gallagher API and encapsulated it as a set of developer products to empower others to build on top of their infrastructure.</p> <p>Born out of solving our client's use cases, we built the Python client to interact with the API to ensure quality and achieve a great developer experience as our offerings scale. As our support requests grew it was evident that we could carve out a set of tools to enhance automation and integrations.</p> <p>We believe that open sourcing these tools will result in a vibrant community of developers that will be able to leverage Gallagher's technology to build incredibly practical applications.</p> <p>The design pattern of the API client is opinionated from our experience as software engineers. We goto great lengths to document our thought process and expression of the work we do. We look forward to your comments and feedback and can't wait to see what you build with our tools.</p>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Security Hub</li> </ul>"},{"location":"cli/","title":"Command Line Interface","text":"<p>We provide a command line interface to interact with the Gallagher Command Centre. It uses the API client to communicate with the server, which doubly serves as a reference example of how to use the API client.</p> <p>We use typer to construct the CLI, which in turn uses click. We also use rich to make the output nicer. The CLI is decoupled from the API client, and is not install by default.</p> <p>We follow a <code>git</code> like <code>command</code>, <code>sub-command</code> pattern, so it should feel quite familiar.</p> <p>uv will install the alias <code>gal</code> for you to interact with the CLI. You can ask for help with:</p>"},{"location":"cli/#resources","title":"Resources","text":"<ul> <li>Command Line Interface Guidelines - clig.dev</li> </ul>"},{"location":"design/","title":"Contributor's Manual","text":"<p>The following guide is aimed at developers who are looking to understand the toolkit at a deeper level or wish to contribute to the project. The aim is to outline the design thinking behind various components of the project.</p>"},{"location":"design/#layout","title":"Layout","text":"<p>It's handy to know where each portion of the project lives, so you can find your way around. Majority of the source is located under the <code>gallagher</code> directory, which is what is shipped via <code>pypi</code>. <code>tests</code> are not part of the distribution and <code>examples</code> are intended to be runnable examples a developer can copy and paste.</p> <pre><code>.\n\u251c\u2500\u2500 assets                          assets for the github/pypi project\n\u251c\u2500\u2500 docs                            documentation via mkdocs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 docs                        where the markdown files are stored\n\u251c\u2500\u2500 examples                        examples of how to use the API client\n\u251c\u2500\u2500 gallagher                       the main package\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 cc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 alarms                  alarms endpoint\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cardholders             cardholders endpoint\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 status_overrides        status overrides endpoint\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 cli                         command line interface\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 tui                         terminal user interface\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dto                         data transfer objects\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 detail                  detail objects\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 payload                 payloads for requests\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ref                     reference objects\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 response                response objects\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 summary                 summary objects\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ext                         extensions to the core package e.g SQL\n\u2514\u2500\u2500 tests                           tests for the project\n</code></pre>"},{"location":"design/#toolchain","title":"Toolchain","text":"<p>Majority of the development was conducted on macOS, but the toolchain should be compatible with any operating system. All elements of the project were developed in <code>python</code> with standard tooling. Our major dependencies are <code>httpx</code> and <code>pydantic</code>.</p> <p>In addition to the usual suspects (e.g pytest) we use:</p> <ul> <li><code>task</code> - as the task runner of choice, it's widely available on platforms and supports Github actions. All endpoints are documented within the command line tool.</li> <li><code>uv</code> as our package manager of choice for the python project</li> <li><code>mkdocs</code> for documentation, maintained using markdown</li> </ul>"},{"location":"design/#sdk","title":"SDK","text":"<p>A central feature to this project is the API client, focused on a superior developer experience and performance we spent substantial time in designing the Python interface to ensure it scales. We also ensure that we follow forward compatibility design patterns outlined by Gallagher (e.g HATEOAS) so you as a developer don't have to worry about it.</p> <p>This chapter is optional if you are simply using the API client or the tools. It's aimed towards developers who choose to extend the client further.</p>"},{"location":"design/#data-transfer-objects","title":"Data Transfer Objects","text":"<p>Data Transfer Objects (DTOs) are used to parse the JSON payloads exchanged with the Gallagher REST endpoints. This is to ensure strict validation of the payloads. At it's heart each one of these classes are a <code>pydatic</code> parser.</p> <p>There are three types of schema definitions, each one of them suffixed with their intent:</p> <ul> <li>Ref are <code>References</code> to other objects, they using contain a <code>href</code> and possibly additional meta data such as a <code>name</code> or <code>id</code></li> <li>Summary is what is returned by the Gallagher API in operations such as searches, these are generally a subset of the full object</li> <li>Detail are the full object found at a particular <code>href</code>, they compound on the <code>Summary</code> schema and add additional attributes</li> <li>Responses are resposnes sent back from the server, these will typically contain a set of <code>Summary</code> or <code>Detail</code> objects. When fetching detailed responses for an object the server will often respond with a <code>Detail</code> object without a wrapper <code>Response</code> object.</li> <li>Payloads are objects that are sent to the server as part of a <code>POST</code> or <code>PUT</code> operation, these are suffixed with Payload, some of these also offer <code>Builder</code> classes to assist with construction of the payload.</li> </ul> <p>I additional we have classes that defined responses which are suffixed with Response, these wrap structures which returns <code>hrefs</code> for <code>next</code> and <code>previous</code> responses and usually have a collection to hold the response.</p> <p>Ensure that each Endpoint defines their own DTOs so you can test them for authenticity. Avoid writing generic classes.</p> <p>While <code>Refs</code>, <code>Summary</code> and <code>Detail</code> responses have fields, and it would make sense from an efficiency point of view to inherit e.g <code>Summary</code> builds on <code>Ref</code>, this should be avoided so logically an instance of a <code>Ref</code> class doesn't assert true for <code>isinstance</code> of a <code>Summary</code> class.</p>"},{"location":"design/#utilities","title":"Utilities","text":"<p>The Developer Experience must be at the heart your thinking when you are extending the SDK, to assist with this the SDK provides the following utilities.</p> <p>Base models - are classes that extend the <code>pyndatic</code> <code>BaseModel</code> class and provide common fields and configuration that are shared across all DTOs. Each DTO must inherit from one of the appropriate base models.</p> <ul> <li><code>AppBaseModel</code> - is what a <code>Ref</code>, <code>Summary</code> or <code>Detail</code> class would inherit from</li> <li><code>AppBaseResponseModel</code> - distinguishes between a model vs a response. A response has results which would in turn be a list of <code>Ref</code> or <code>Summary</code> objects</li> <li><code>AppBaseResponseWithFollowModel</code> - as response as model as the one before but with <code>next</code>, <code>previous</code>, or <code>update</code> links (depending on the use case)</li> </ul> <p>Mixins - are Python classes that inject a particular behaviour into a DTO. They abstract concepts like <code>id</code>, <code>href</code> and <code>optional_href</code> (which is defined using an annotation).</p> <ul> <li><code>IdentityMixin</code> - provides an <code>id</code> field</li> <li><code>HrefMixin</code> - provides an <code>href</code> field</li> <li><code>OptionalHrefMixin</code> - provides an <code>href</code> field that is optional</li> </ul> <p>using these is as simple as inheriting from them in your DTO classes e.g:</p> <pre><code>from gallagher.dto.mixins import (\n    IdentityMixin,\n    HrefMixin,\n    AppBaseModel,\n)\n\nclass CardholderSummary(\n    AppBaseModel,\n    IdentityMixin,\n    HrefMixin,\n):\n    \"\"\"Summary of a cardholder\n\n    This is a summary of a cardholder, it is typically returned\n    in a list of cardholders.\n\n    It would have an id and href field because of the Mixin\n    \"\"\"\n\n    first_name: str\n    last_name: str\n    authorised: bool\n</code></pre>"},{"location":"design/#writing-dto-classes","title":"Writing DTO classes","text":"<p>DTOs are essentially <code>pyndatic</code> data models with some design assumptions. Most of these are around helpers we provide along with naming and placement conventions:</p> <ul> <li>Suffix names with utlity - we debated this a lot before deciding that it was more utiliatarian to suffix the classes with their utility e.g <code>CardholderSummary</code>, <code>CardholderDetail</code>, <code>CardholderRef</code>, this voids the needs for formally importing the classes and then aliasing them.</li> <li>Use Mixins - to provide common fields across DTOs, this reduces code duplication and ensures consistency, so wherever possible use the provided Mixins.</li> <li>Caution on using OptionalHrefMixin - this Mixin was initially introduced to model the HATEOAS discovery pattern (which we call the Discovery pattern), while this proves useful in some other use cases, we advice caution in making a <code>href</code> optional as we prefer to have a strict schema.</li> <li>Placement of DTOs - In most cases your DTOs will be placed by function e.g <code>ref</code>, <code>summary</code>, <code>detail</code>, however in cases where a model is returned explicitly as part of say a Detail response, and expands attributes e.g <code>CardholderAccessGroupSummary</code> (which defines a card assigned to a Cardholder) then this should be placed in the same page as the <code>detail</code>. In the inline examples you will find this in <code>detail/cardholder.py</code>.</li> </ul>"},{"location":"design/#conflicts-with-python-reserved-words","title":"Conflicts with Python Reserved Words","text":"<p>Gallagher's API uses certain <code>keys</code> e.g <code>from</code> in their <code>json</code> responses that are reserved words in Python. To handle this we use the <code>pydantic</code> <code>Field</code> class to alias these fields. These are defined as annotations that you should use across the DTOs. A sample definition looks like (found in <code>dto/utils.py</code>):</p> <pre><code>from_optional_datetime = Annotated[\n    Optional[datetime],\n    Field(..., alias=\"from\")\n]\n</code></pre> <p>Our current aliases are:</p> <ul> <li><code>from_optional_datetime</code> - which is to be used for the <code>from</code> date fields</li> <li><code>until_optional_datetime</code> - which is to be used for the <code>until</code> date fields, while <code>until</code> is not a reserved word in Python, we've chosen to use this to be consistent with the <code>from</code> field</li> </ul> <p><code>type</code> is another <code>key</code> that that constant appears in the <code>JSON</code> payloads, while this is a reserved function name in Python, it does not conflict with the compiler when used as a variable name. For now we've chosen not to wrap this in an alias.</p>"},{"location":"design/#custom-headers","title":"Custom Headers","text":"<p>The <code>httpx</code> wrappers sets the following headers for all requests sent to the command centre:</p> <ul> <li><code>Content-Type</code> set to <code>application/json</code> to let the command centre know that we are sending JSON payloads</li> <li><code>User-Agent</code> set of <code>GallagherPyToolkit/1.0</code> where <code>1.0</code> is the version number discovered from <code>gallagher/__init__.py</code></li> <li><code>Authorization</code> set to <code>GGL-API-KEY 9939-00-</code> as prescribed by the official documentation</li> </ul>"},{"location":"design/#api-client-core","title":"API Client Core","text":"<p>The <code>core</code> package in <code>cc</code> provides two important classes:</p> <ul> <li><code>APIEndpoint</code> which all endpoint consumers configuration must inherit from</li> <li><code>EndpointConfig</code> an instance of which each class must return as a result of the <code>get_config</code> method</li> </ul> <p>Every Endpoint Consumer Class is expected to return an instance of <code>EndpointConfig</code> from the <code>get_config</code> method. Each configuration provides references to paths that are dynamically discovered as part of our bootstrapping process.</p> <p>Never hard code URLs as this violates the HATEOAS design principle.</p> <p>Additionally each configuration will provide references to DTO classes that is used to parse responses, and details of the body.</p> <pre><code>class Alarms(\n    APIEndpoint\n):\n    \"\"\" Alarms\n    \"\"\"\n\n    @classmethod\n    async def get_config(cls) -&gt; EndpointConfig:\n        return EndpointConfig(\n            endpoint=Capabilities.CURRENT.features.alarms.alarms,\n            dto_list=AlarmSummaryResponse,\n            dto_retrieve=AlarmSummary,\n        )\n</code></pre> <p>The above example shows the <code>Alarms</code> class which is a consumer of the <code>alarms</code> endpoint. It nominates <code>AlarmSummaryResponse</code> as the class the infrastructure will use to parse <code>list</code> responses and <code>AlarmSummary</code> as the class to parse <code>retrieve</code> responses.</p> <p>It references the <code>Capabilities.CURRENT</code> singleton which is a <code>Capabilities</code> instance that is bootstrapped at runtime. This is a singleton that is used to provide references to all endpoints.</p> <p>If a command centre does not have a certain capability then the objects are set to <code>None</code> and accessing the feature raises an exception (more on this in other sections).</p>"},{"location":"design/#transport-wrappers","title":"Transport Wrappers","text":"<p><code>APIEndpoint</code> has several helper methods that reduce code duplication and ensures that the HTTP call lifecycle is handled properly.</p> <ul> <li><code>_get</code> - provides a wrapper for HTTP <code>GET</code> calls, this takes in a mandatory <code>url</code> and an optional <code>response_class</code> which must be a subclass of <code>AppBaseModel</code>, typically a <code>Detail</code> or a <code>Response</code> class</li> <li><code>_post</code> - provides a wrapper for HTTP <code>POST</code> calls, and like <code>_get</code> takes in a <code>url</code> and <code>response_class</code>. In addition you pass in <code>payload</code> which must also be a subclass of <code>AppBaseModel</code>.</li> </ul> <p>These wrappers raise the following <code>Exceptions</code> when they encounter the corresponding HTTP codes:</p> <ul> <li><code>gallagher.exception.UnlicensedFeatureException</code> on <code>HTTPStatus.FORBIDDEN</code> when an unlicensed endpoint is accessed (see the discovery section for details)</li> <li><code>gallagher.exception.NotFoundException</code>on<code>HTTPStatus.NOT_FOUND</code>(GET only) - raised if a HTTP endpoint wasn't found e.g A<code>Detail</code> object wasn't found</li> <li><code>gallagher.exception.ComingSoonException</code> - raised if a feature is marked as \"coming soon\" by Gallagher</li> <li><code>gallagher.exception.DeadEndException</code> - raised if you try and follow a path i.e <code>next</code> or <code>previous</code> on an endpoint that supports it but no longer has a path forward or back.</li> <li><code>gallagher.exception.AuthenticationError</code> on <code>HTTPStatus.UNAUTHORIZED</code> if there are issues with authentication</li> <li><code>gallagher.exception.PathFollowNotSupportedError</code> - raised if you try and call <code>next</code> or <code>previous</code> on an endpoint that does not support path follow.</li> </ul>"},{"location":"design/#designing-endpoint-consumers","title":"Designing Endpoint Consumers","text":"<p>Each API consumer inherits from <code>APIEndpont</code> which is defined in <code>gallagher.cc.core</code>. Before each endpoint is executed we run an internal discovery process (see the <code>_discover</code> method in <code>APIEndoint</code> class).</p> <p>We do this to be forwards compatible (see HATEOAS chapter in Gallagher's documentation), but caches the response across a session (a session being an application life cycle) to increase API round trip performance.</p> <p>The discovered state of the server is stored in a singleton, that's used by all the API endpoints. This can be found in the <code>core</code> package, as the <code>CURRENT</code> attribute of the <code>Capabilities</code> class. This is always an instance of <code>DiscoveryResponse</code>. Because this is instantiated as part of the bootstrap, initially all the URLs are set to <code>None</code>, the values are populated ahead of the first API call made to the server.</p> <p>For this reason all <code>APIEndpoint</code> classes return a configuration as a result of a function called <code>get_config</code> (an <code>async</code> method that at a <code>class</code> scope) as opposed to a statically assigned class variable (otherwise the URLs would always result to be the initial <code>None</code> value).</p> <p>Tip</p> <p>If you want to force discovery of the endpoints call <code>expire_discovery</code> on the <code>APIEndpoint</code> before calling the API endpoint. e.g <code>Cardholder.expire_discovery()</code></p> <pre><code>from ..core import (\n    Capabilities,\n    APIEndpoint,\n    EndpointConfig\n)\n\nfrom ...dto.detail import (\n    DivisionDetail,\n)\n\nfrom ...dto.response import (\n    DivisionSummaryResponse,\n)\n\nclass Division(APIEndpoint):\n    \"\"\"\n    Gallagher advises against hard coding the URLs for divisions, and instead\n    recommends using the /api endpoint to discover the URLs from\n    events.divisions.href and alarms.division.href.\n\n    \"\"\"\n\n    @classmethod\n    async def get_config(cls) -&gt; EndpointConfig:\n        return EndpointConfig(\n            endpoint=Capabilities.CURRENT.features.divisions.divisions,\n            dto_list=DivisionSummaryResponse,\n            dto_retrieve=DivisionDetail,\n        )\n</code></pre>"},{"location":"design/#cli","title":"CLI","text":"<p>Typer enhances click by providing a mode <code>FastAPI</code> like developer experience (having been created by the developers of FastAPI). The design of our <code>cli</code> is highly inspired by tools like <code>git</code>, and follows the subcommand pattern.</p> <p>This section outlines thoughts on the design of the command line interface for those working on extending it.</p>"},{"location":"design/#extending-dtos-for-the-cli","title":"Extending DTOs for the CLI","text":"<p>The CLI interrogates the DTOs to build it's output. It does this by calling a set of predefined methods. These methods appear on the <code>Response</code> that in turn interrogates the <code>Summary</code> or <code>Detail</code> objects. You must think of these methods as returning a representation of itself for the command line.</p> <p>Tip</p> <p>You are not responsible for formatting the output, the CLI will do this for you. The DTO is solely responsible for returning the data.</p> <p>If you are extending the CLI then please read the design patterns for presenting output. Remember, Developer Experience and Consistency is key.</p> <p>A <code>Response</code> class must provide a representation of results it holds. Note that not all responses from the Gallagher API return the same keys, so you will have to override the methods per <code>Response</code> class.</p> <p>The <code>cli_header</code> returns an array of strings that the CLI will use as headers for the table:</p> <pre><code>@property\ndef cli_header(self):\n    return [\"Id\", \"First name\", \"Last name\", \"Authorised\"]\n</code></pre> <p>The length of this list must match the length of the <code>__rich_repr__</code> method.</p> <p>Next the CLI depends on calling the <code>__rich__repr__</code> method which standard rich representation (Typer and our CLI depends on the <code>rich</code> library to produce output). In many cases this created by amalgamating the fields form the results:</p> <pre><code>def __rich_repr__(self):\n    return [r.__rich_repr__() for r in self.results]\n</code></pre> <p>Finally the CLI depends on the standard <code>__str__</code> function to present sumamries of the results. Be mindful of what you send back as a response from this.</p> <pre><code>def __str__(self):\n    return f\"{len(self.results)} cardholders\"\n</code></pre> <p>Putting all this together if you were to return a list of <code>Cardholders</code> as part of the <code>Summary</code> call, it looks somewhat like this:</p> <pre><code>class CardholderSummaryResponse(\n    AppBaseResponseModel,\n):\n    \"\"\"Summary response for cardholder list and search\n\n    /api/cardholders is generally the endpoint that responds\n    to the query, it is dynamically configured from the discovery\n\n    \"\"\"\n\n    results: list[CardholderSummary]\n\n    @property\n    def cli_header(self):\n        return [\"Id\", \"First name\", \"Last name\", \"Authorised\"]\n\n    def __rich_repr__(self):\n        return [r.__rich_repr__() for r in self.results]\n\n    def __str__(self):\n        return f\"{len(self.results)} cardholders\"\n</code></pre>"},{"location":"design/#tui","title":"TUI","text":""},{"location":"design/#sql","title":"SQL","text":"<p>The SQL interface is built using the <code>shillelagh</code> library. The library exposes various <code>metadata</code> which the extension gathers to construct the SQL interface. The following is a guide to outline how that works and what you require to populate should you wish to extend or contribute to the SQL interface.</p> <p>Each API Endpoint configuration that wishes to support the SQL interfaces returns a constant named <code>__shillelagh__</code> which is a tuple of classes that are used to query the endpoint. The classes must be a subclass of <code>AppBaseResponseModel</code> and must implement a <code>result_set</code> property that returns a reference to the property that provides the resultset for the SQL queries.</p> <pre><code># Write up Alarms for querying via the SQL interface\n__shillelagh__ = (\n    Alarms,\n)\n</code></pre> <p>The following demonstrates two examples where <code>CardholderSummaryResponse</code> returns the <code>results</code> property</p> <pre><code>class CardholderSummaryResponse(AppBaseResponseModel):\n    \"\"\"Summary response for cardholder list and search\n\n    /api/cardholders is generally the endpoint that responds\n    to the query, it is dynamically configured from the discovery\n\n    \"\"\"\n\n    results: list[CardholderSummary]\n\n    @property\n    def result_set(self) -&gt; list[CardholderSummary]:\n        \"\"\" Wrap summary response target property\n\n        the sql interface will call this property and each summary\n        response is expected to override this and return the appropriate\n        target property\n        \"\"\"\n        return self.results\n</code></pre> <p>whereas <code>AlarmSummaryResponse</code> nominates the <code>alarms</code> property.</p> <pre><code>class AlarmSummaryResponse(AppBaseResponseModel):\n    \"\"\"AlarmSummaryResponse represents a single alarm\"\"\"\n\n    alarms: list[AlarmSummary]\n    updates: OptionalHrefMixin = None\n\n    @property\n    def result_set(self) -&gt; list[AlarmSummary]:\n        \"\"\" Wrap summary response target property\n\n        the sql interface will call this property and each summary\n        response is expected to override this and return the appropriate\n        target property\n        \"\"\"\n        return self.alarms\n</code></pre> <p>Both of these make for the <code>results</code> of the SQL</p>"},{"location":"design/#maintainers-notes","title":"Maintainers Notes","text":"<p>This section primarily contains notes for the managers of the project, it covers topics like publication of releases.</p> <p>Much of this is automated via Github actions, these actions depend on the following secrets that have been set at a project level (and can only be updated by the project owners):</p> <ul> <li><code>PYPI_API_KEY</code> - the API key for PyPI that is used to publish the package</li> <li><code>GACC_API_KEY</code> - the API key for the Gallagher Command Centre that is used to run tests against.</li> </ul>"},{"location":"design/#publishing-a-release","title":"Publishing a Release","text":"<p>The action <code>.github/workflows/publish-package.yml</code> is responsible for publishing a release. This is triggered by a tag being pushed to the repository. The tag must be in the format <code>vX.Y.Z</code> where <code>X</code>, <code>Y</code> and <code>Z</code> are integers.</p> <p>The <code>release</code> action will run the set of tests, and if they pass, it will publish the package to PyPI.</p> <p>Important</p> <p>In most instances you should not have to publish a release by hand. If there is ever a need to do that, we recommend that appropriate notes be left against the release.</p>"},{"location":"design/#writing-release-notes","title":"Writing Release Notes","text":"<p>With every release we must ensure that this documentation is kept relevant and we leave a trace of what has changed in beautifully written release notes.</p> <p>\" If you don't have documentation, you don't have a minimum viable product.\" - Paige Bailey</p> <p>The project recommends the following pattern, which is enforced by a template in our Github workflow. We understand that you can use generative AI tools to write your release notes, but we believe that users of this library want to hear what us the maintainers thought is important as opposed to a computed list of changes.</p> <p>We understand it takes that little bit longer to do this right, doing this well shows our level of care.</p> <ul> <li>Preamble, a summary of the release where we outline the major motivation (be it a feature or a service release)</li> <li>Features, a concise list of what we have added to this release and did not exist before</li> <li>Improvements, a list of improvements made to existing features</li> <li>Bug Fixes, this is different to <code>improvements</code> these are genuine issues that were found</li> </ul> <p>Includes the sections relevant and leave out what's not. Be as human as possible, this is a conversation with our users.</p>"},{"location":"installation/","title":"Installation &amp; Usage","text":"<p>What you need to install will widely depend on if you are looking to use our tools, building software with our libraries or contributing to the project. This guide will get you set up for each one of the use cases. While the end user tools do not require software development experience, the other development tools are biased towards Python developers.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>You will require Python 3.10 or above to run the SDK and tools. We provide containerised versions and binaries for most popular platforms. Please keep reading for specific instructions.</p>"},{"location":"installation/#installation","title":"Installation","text":"<p>In the most trivial cases we recommend installation via <code>PyPI</code>. The package is designed such that you only install what you need. The SDK is required by all our tools, hence it's the lowest common denominator.</p> <p>The SDK can be installed by adding it as a dependency to your project:</p> <pre><code>uv add gallagher\n</code></pre> <p>If you are feeling adventurous you can install everything by:</p> <pre><code>uv add gallagher[all]\n</code></pre>"},{"location":"installation/#sdk","title":"SDK","text":"<p>To use the API (or the associated tools, as they use the API client in return) you must have an API key supplied by the Command Centre instance. The same key is used if you were were using the API on premise or in the cloud.</p> <p>You would typically read the API key from an environment variable or a secrets manager, depending on your setup.</p> <p>You should only ever setup the API key once in your application instance. The rest of the client is designed to discover. An example of how you would do this would look like:</p> <pre><code>from gallagher import cc\napi_key = os.environ.get(\"GACC_API_KEY\")\ncc.api_key = api_key\n</code></pre> <p>following this you can call any of the SDK methods and the client will performance the necessary discovery and authentication. If you fail to set the API key, the client will raise the following exceptions:</p> <ul> <li><code>NoAPIKeyProvidedError</code> - If the API key is not set.</li> <li><code>ValueError</code> - If the API key does not conform to the expected format (which looks like eight tokens separated by <code>-</code>).</li> </ul>"},{"location":"installation/#using-tls-certificates","title":"Using TLS certificates","text":"<p>Command Centre optionally allows you to use self signed client side TLS certificates for authentication. You can use this along side your API key as an additional layer of security.</p> <p>You can use <code>openssl</code> to generate yourself a client side certificate and key.</p> <pre><code>openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout client.key -out client.pem\n</code></pre> <p>Fill in the required details for the certificate and then generate a <code>sha1</code> hash of the certificate.</p> <pre><code>openssl x509 -in client.pem -noout -fingerprint -sha1\n</code></pre> <p>Note that the Command Centre does not use the <code>colon</code> separated format, see their documentation for more information.</p> <p>Once you have completed these steps all you have to do is provide the path to the certificate and key files to the client.</p> <pre><code>from gallagher import cc\napi_key = os.environ.get(\"GACC_API_KEY\")\ncc.api_key = api_key\n\ncc.file_tls_certificate = '/path/to/client.pem'\ncc.file_private_key = '/path/to/client.key'\n</code></pre> <p>The rest of the requests and operations remain the same, the library will use an <code>SSL Context</code> to do the needful.</p> <p>Our testsuites are configured to run with and without TLS certificates to ensure that we support both modes of operation.</p> <p>In instances (such as Github actions, where we store the certificate and key in the Github secrets manager) where you can't store the certificate and key in the filesystem, you can use Python's <code>tempfile</code> module to create temporary files and clean up once you are done using them.</p> <pre><code>import tempfile\n\n# Read these from the environment variables, if they exists\n# they will be written to temporary files\ncertificate_anomaly = os.environ.get(\"CERTIFICATE_ANOMALY\")\nprivate_key_anomaly = os.environ.get(\"PRIVATE_KEY_ANOMALY\")\n\n# Create temporary files to store the certificate and private key\ntemp_file_certificate = tempfile.NamedTemporaryFile(\n    suffix=\".crt\",\n    delete=False\n)\ntemp_file_private_key = tempfile.NamedTemporaryFile(\n    suffix=\".key\",\n    delete=False\n)\n\n# Write the certificate and private key to temporary files\nif certificate_anomaly and temp_file_certificate:\n    temp_file_certificate.write(certificate_anomaly.encode('utf-8'))\n\nif private_key_anomaly and temp_file_private_key:\n    temp_file_private_key.write(private_key_anomaly.encode('utf-8'))\n</code></pre> <p>You can assign these temporary files to the client as shown above.</p> <pre><code>from gallagher import cc\n\ncc.api_key = api_key\ncc.file_tls_certificate = temp_file_certificate.name\ncc.file_private_key = temp_file_private_key.name\n</code></pre>"},{"location":"installation/#command-line-interface","title":"Command line interface","text":""},{"location":"installation/#terminal-user-interface","title":"Terminal user interface","text":""},{"location":"installation/#sql-support","title":"SQL support","text":""},{"location":"installation/#developer-notes","title":"Developer notes","text":"<p>This library uses httpx as the HTTP transport and pydantic to construct and ingest payloads. We use taskfile to run tasks. Our test suite is setup using <code>pytest</code>.</p> <p>Anomaly has a demo Command Centre set up in the cloud that we run tests against. This is populate using a sample site configuration. There are no real security controllers connected to this instance. Upon a PR being lodged, Github actions is configured to run the entire test suite against our demo instance.</p> <p>To contribute to the library, please fork this repository and lodge a pull request for us to accept your changes.</p>"},{"location":"installation/#taskfile","title":"Taskfile","text":"<p>Task is a task runner / build tool that aims to be simpler and easier to use than, for example, GNU Make. Gallagher Python Toolkit uses Task to run common tasks such as testing, linting, and building the documentation. First follow the installation steps to install Task on your system.</p> <p>All the <code>tasks</code> are quite logically grouped and most of them will need you to have a <code>virtualenv</code> initialised via <code>uv</code>.</p> <p>Info</p> <p>Our Github workflows use Task via the Github action.</p> <p>Some of the <code>task</code> targets take parameters e.g.</p> <p><code>task test</code> will run the entire test suite, while <code>task test -- test_cardholder.py</code> will run only the tests in <code>test_cardholder.py</code>.</p>"},{"location":"installation/#building-the-docs","title":"Building the docs","text":"<p>The documentation is build using mkdocs and hosted on Github pages. The project repository is configured to build and publish the documentation on every commit to the <code>master</code> branch.</p> <p>Some handy commands to get you started:</p> <ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve -a localhost:8003</code> - Start the live-reloading docs server, <code>-a</code> allows you to provide a custom address.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul> <p>We have a wrapper for running the <code>mkdocs</code> web server at <code>task dev:docs</code> which runs the server on port <code>8001</code>.</p> <p>To start contributing please fork this repository, make the changes you desire and submit a pull request for us to merge your changes in. Alternatively consider starting a discussion or raising an issue. Be kind to our maintainers and check to see if a similar discussion is already in place and join the thread.</p>"},{"location":"python-sdk/","title":"Python API Client","text":"<p>Gallagher Python Toolkit started life with the API Client, and it underpins all the utilities GPT ships. The central theme in the API client is data validation for responses and payloads. We take the approach of \"nothing can go wrong\" when we are interacting with a Gallagher Command Centre. We put in enormous effort into maintaining this SDK with the following aims:</p> <ul> <li>Stellar DX - We've put immense effort in designing the programming interface to provide a stellar developer experience. If you've worked with well designed API clients like Stripe, you should feel right at home.</li> <li>Merciless validation - built on top of pydantic the SDK ensures extremely strong data validation, reenforced with a complete set of tests.</li> <li>Designed to Perform - throughout the development we identified and fine tuned every portion to steal milliseconds back without compromising on the reliability.</li> <li>Future proof - HATEOAS support ensures that the SDK is future proof and designed to standards outlined by Gallagher.</li> <li>Built for tomorrow - <code>asyncio</code> support ensures that the SDK is ready for the upcoming future of Python.</li> </ul>"},{"location":"python-sdk/#setup","title":"Setup","text":"<p>For most use cases we recommend installing a stable version from <code>pypi</code>.</p> <p>Install via <code>pip</code> as follows:</p> <pre><code>pip install gallagher\n</code></pre> <p>or if you are using <code>uv</code>:</p> <pre><code>uv add gallagher\n</code></pre> <p>For production application please make sure you target a particular version of the API client to avoid breaking changes.</p>"},{"location":"python-sdk/#data-transfer-objects-dto-premiere","title":"Data Transfer Objects (DTO) premiere","text":"<p>The Data Transfer Objects or DTOs are the centre piece of the Python SDK. These are built using the much loved pyndatic library. The aim is strict validation of responses and request payloads to ensure that the SDK never falls out of line with Gallagher' REST API.</p> <p>Before every pull request is merged into our main branch, we run a full test suite against a demo Command Centre. See the actions tab for a status of the latest build.</p> <p>DTOs are classified into:</p> <ul> <li><code>Refs</code> are the minimal pathway to an object</li> <li><code>Summary</code> builds on a <code>Ref</code> and provides a subset of the attributes</li> <li><code>Detail</code> builds on a <code>Summary</code> and provides the full set of attributes</li> </ul> <p>A DTO is a subclass of one and only one of the above base classes. They deliberately do not inherit from each other so you can test of truths i.e a <code>ref</code> will never equate to a <code>summary</code> or a <code>detail</code>.</p> <p>In addition to DTOs, you will see a number of :</p> <ul> <li><code>Response</code> objects, which encapsulates a collection of <code>Summary</code> objects, they typically have <code>next</code> and <code>previous</code> paths for pagination</li> <li><code>Payload</code> are the objects that are sent to the Command Centre to create or update an object</li> </ul> <p>If you are fetching a <code>detail</code> then they are returned on their own as part of the response. They typically contain <code>href</code> to related objects.</p>"},{"location":"python-sdk/#api-endpoint-lifecycle","title":"API endpoint lifecycle","text":"<p>You do not need to look under the hood to work with the API client. This section was written for you to understand how we implement Gallagher's requirements for standard based development. Each endpoint inherits from a base class called <code>APIEndpoint</code> defined in <code>gallagher/cc/core.py</code> and provides a configuration that describes the behaviour of the endpoint (in accordance with the Command Centre API).</p> <p>Before your request is sent, the endpoint will:</p> <ul> <li>Run a method called <code>_discover</code> (this is only ever run once per session, i.e so long as the client instance is in memory), this discovers and caches API endpoints in accordance to the HATEOAS principle.</li> <li>The <code>get_config</code> method is executed to bootstrap the environment and using the above discovery results.</li> <li>Runs your request and returns the response where appropriate.</li> </ul> <p>You can read about his in our design document.</p>"},{"location":"python-sdk/#configuration","title":"Configuration","text":"<p>You are required to set the <code>api_key</code> once across your usage of the SDK. You can typically do this by import <code>cc</code> from the <code>gallagher</code> package and setting the <code>api_key</code> attribute.</p> <pre><code>import os\nfrom gallagher import cc\n\napi_key = os.environ.get(\"GACC_API_KEY\")\ncc.api_key = api_key\n</code></pre> <p>You can obviously obtain the <code>api_key</code> from a secure location such as a secret manager or a configuration file.</p> <p>Warning</p> <p>Never publish the API Key in your code or in a public repository. API keys have various levels of permission on your command centre and leaking the key can cause serious damage.</p> <p>If you think your API key has been compromised, please revoke it immediately.</p> <p>By default the API client is configured to use the <code>Australian</code> cloud gateway to communicate with your Command Centre. You can override this to:</p> <ul> <li>FQDN of a different cloud gateway (currently supported are Australia and United States)</li> <li>IP address of a cloud gateway (current supported are Australia and United States)</li> <li>FQDN or IP address of a local Command Centre (not using a cloud gateway)</li> </ul> <p><code>gallagher.const</code> provides an easy way to reference these values and are maintained by the SDK. We recommend you rely on them, instead of hardcoding the values in your application.</p> <p>If you wish to target a different cloud gateway, use the constants:</p> <ul> <li><code>URL.CLOUD_GATEWAY_AU</code> - for the Australian cloud gateway</li> <li><code>URL.CLOUD_GATEWAY_US</code> - for the United States cloud gateway</li> </ul> <p>If you wish to target the cloud gateway via IP address, use the constants:</p> <ul> <li><code>IP_ADDR.CLOUD_GATEWAY_AU</code> - for the Australian cloud gateway</li> <li><code>IP_ADDR.CLOUD_GATEWAY_US</code> - for the United States cloud gateway</li> </ul> <p>Note</p> <p>If you target the cloud gateway via IP addresses, Gallagher provides a set of addresses which are passed as an array to the <code>APIEndpoint</code> class. The SDK will automatically cycle through the addresses in case of a failure.</p> <p>You can override the address of the gateway in a similar the way to setting the <code>api_key</code>:</p> <pre><code>from gallagher import cc\nfrom gallagher.const import URL\n\ncc.api_base = URL.CLOUD_GATEWAY_US\n</code></pre> <p>In cases where you are targeting a local Command Centre, you can set the <code>api_base</code> to the FQDN or IP address of the Command Centre that's locally accessible on the network.</p>"},{"location":"python-sdk/#proxy-support","title":"Proxy support","text":"<p>Thanks to <code>httpx</code> we have proxy support built in out of the box. By default the <code>proxy</code> is set to <code>None</code> indicating that one isn't in use. If you wish to use a proxy for your use case, then simply set the <code>proxy</code> attribute on the <code>cc</code> object like you would the <code>api_base</code> or <code>api_key</code>.</p> <pre><code>from gallagher import cc\n\ncc.proxy = \"http://username:password@proxy.example.com:8080\"\n</code></pre> <p>For information on advanced configuration options see the httpx documentation. As always be very careful where you retrieve the proxy information from, and do not version control it.</p>"},{"location":"python-sdk/#usage","title":"Usage","text":"<p>Once you have an environment up and running you can start using the SDK to interact with the Command Centre API. The following demonstrates a very basic example of fetching a list of cardholders.</p> <p>If the command centre returns a result the SDK will parse the response and return a Python object which you can interact with or use for further queries.</p> Basic Usage<pre><code># Import core python libs\nimport os\nimport asyncio\n\n# Import the client and models\nfrom gallagher import (\n    cc,\n)\nfrom gallagher.dto.summary import (\n    CardholderSummary,\n)\nfrom gallagher.cc.cardholders import (\n    Cardholder,\n)\n\n# Set the API key from the environment\napi_key = os.environ.get(\"GACC_API_KEY\")\ncc.api_key = api_key\n\n# Async support gives us back a coroutine\nch_coro = Cardholder.list()\n\n# Run the coroutine to get the cardholder\ncardholders = asyncio.run(ch_coro)\ncardholder = cardholders.results[0]\n\n# This is now a pydantic object\ntype(cardholder) == CardholderSummary\n\n# Print out some details from the object\ncardholder.href\ncardholder.first_name\n</code></pre> <p>Note</p> <p>We encourage the use of <code>asyncio</code> where possible. In case you are unable to use <code>asyncio</code> please refer to our advanced guide for strategies to work around this.</p> <p>We provide a streamlined pattern of calls that the developers can use across data types to access the various Gallagher API Endpoints. For the purposes for this guide we will use the <code>Item</code> endpoint to elaborate how the SDK wraps the usual suspects and additional methods (where applicable to endpoints).</p> <p>Each Endpoint has a configuration that determines which ones of the following methods are available. While our documentation outlines what is available, you will be met with an exception if you happen to call a method that isn't supported by the endpoint.</p>"},{"location":"python-sdk/#lists","title":"Lists","text":"<p>The simplest interaction you can have with objects is to get a summary of objects. We refer to this operation as a <code>list</code> and they can be accessed by calling the <code>list</code> method on the appropriate endpoint. Each list method returns a <code>Response</code> object which contains a list of <code>Summary</code> or <code>Ref</code> objects.</p> <p>These summary of ref objects are contained in a collection usually called <code>results</code> (this can vary per endpoint), the results are iterable, each item will be parsed object of the nominated model.</p> <pre><code>from gallagher.dto.summary import (\n    ItemSummary,\n)\n\nfrom gallagher.dto.response import (\n    ItemTypesResponse,\n    ItemsSummaryResponse,\n)\n\nfrom gallagher.cc.alarms.items import Item\n\n# Get a list of items\nresponse = await Item.list()\n\n# Print the href to prove we have results\nfor item in response.results:\n    print(item.href)\n</code></pre>"},{"location":"python-sdk/#detail","title":"Detail","text":"<p>You can fetch a detail of an object by calling the <code>retrieve</code> method on the appropriate endpoint. The <code>retrieve</code> method requires an <code>id</code> for the object and returns a <code>Detail</code> object which contains the full set of attributes for the object.</p> <pre><code>from gallagher.dto.summary import (\n    ItemSummary,\n)\n\nfrom gallagher.dto.response import (\n    ItemTypesResponse,\n    ItemsSummaryResponse,\n)\n\nfrom gallagher.cc.alarms.items import Item\n\n# Get a list of items\ndetail_response = await Item.retrieve(399)\n</code></pre> <p>Note</p> <p>The <code>retrieve</code> method uses <code>id</code> instead of a reference to an object because it's a generic wrapper wants to construct the URL based on the parameter rather than the developer passing in a <code>href</code> which could result in the user passing in an <code>href</code> to a different object.</p>"},{"location":"python-sdk/#search","title":"Search","text":""},{"location":"python-sdk/#creating","title":"Creating","text":""},{"location":"python-sdk/#deletion","title":"Deletion","text":""},{"location":"python-sdk/#additional-methods","title":"Additional Methods","text":"<p>Many of the endpoints provide additional mutations to interact with the Command Centre. The SDK makes sensible decisions to combine endpoints where it makes sense. For example, the <code>Alarm</code> endpoint provides an endpoint to mark an alarm as viewed, additionally with a comment.</p> <pre><code>    @classmethod\n    async def mark_as_viewed(\n        cls,\n        alarm: AlarmRef | AlarmSummary | AlarmDetail,\n        comment: Optional[str],\n    ) -&gt; bool:\n</code></pre>"},{"location":"python-sdk/#next-and-updates","title":"Next and Updates","text":"<p>If an <code>APIEndpoint</code> claims that to supports pagination, it will automatically expose the following methods. Each one of these is designed to follow the path based on the responses from the Gallagher API. You are to rely on the <code>next</code>, or <code>previous</code> attribute to determine if there are more items to fetch.</p> <ul> <li><code>next</code> - uses the <code>next</code> <code>href</code> to follow the next set of items</li> <li><code>previous</code> - uses the <code>previous</code> <code>href</code> to follow the previous set of items</li> </ul> <pre><code>items_summary = await Item.list()\n\n# Iterate until the next attribute is None\nwhile items_summary.next:\n    # Will use the next href to fetch the next set of items\n    items_summary = await Item.next(items_summary)\n</code></pre> <p>Note</p> <p>You don't provide a <code>url</code> or <code>href</code> to the <code>next</code> or <code>previous</code> methods, they are automatically determined from the response object. This ensures that we can update the SDK as the API changes leaving your code intact.</p>"},{"location":"python-sdk/#follow-for-changes","title":"Follow for changes","text":"<p>Entities like <code>Cardholders</code>, <code>Alarms</code>, <code>Items</code>, and <code>Event</code> provide <code>updates</code> or <code>changes</code>, that can be monitored for updates. Essentially these are long poll endpoints that:</p> <ul> <li>Provide a set of recent update as a <code>Summary</code> Response</li> <li>End with an <code>next</code> URL which provides the next set of updates</li> <li>Returns an empty set of updates if there are no updates within around 30 seconds</li> <li>Always returns a <code>next</code> URL to follow, even in the case of an empty set of updates</li> </ul> <p>The SDK provide a clean <code>async</code> way of following these updates where you can run a <code>for</code> loop over an <code>async</code> generator which <code>yields</code> updates as they are available.</p> <p>It uses an <code>asyncio</code> event to control the loop, and you can stop the loop by calling <code>event.clear()</code>. This is so you can control the event loop based on an application level trigger e.g a user navigating to a particular interface.</p> <p>Here's a sample of how you can follow updates and stop the loop if there are no updates:</p> <pre><code>import os\nimport asyncio\n\nfrom gallagher import cc\nfrom gallagher.cc.alarms import Alarms\n\nasync def main():\n    api_key = os.environ.get(\"GACC_API_KEY\")\n    cc.api_key = api_key\n\n    # Used to control the event loop\n    asyncio_event = asyncio.Event()\n\n    async for updates in Alarms.follow(\n        asyncio_event=asyncio_event,\n    ):\n\n        for update in updates.updates:\n            print(update)\n\n        # Examples of stopping the loop if\n        # we got no updates\n        if len(updates.updates) == 0:\n            asyncio_event.set()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Endpoints that provide either an `</p>"},{"location":"sql/","title":"SQL and SQLAlchemy","text":""},{"location":"sql/#shillelagh","title":"Shillelagh","text":""},{"location":"sql/#querying","title":"Querying","text":""},{"location":"sql/#filtering","title":"Filtering","text":""},{"location":"sql/#using-order-limit-offset","title":"Using ORDER, LIMIT, OFFSET","text":""},{"location":"sql/#sqlalchemy-dialect","title":"SQLAlchemy dialect","text":""},{"location":"sql/#virtual-tables","title":"Virtual Tables","text":""},{"location":"tui/","title":"Terminal User Interface","text":""}]}